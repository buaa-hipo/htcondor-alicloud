diff -ru glibc-2.3.2.27.9.7.orig/c_stubs/gconv_stubs.c glibc-2.3.2.27.9.7/c_stubs/gconv_stubs.c
--- glibc-2.3.2.27.9.7.orig/c_stubs/gconv_stubs.c	2003-03-22 13:55:28.000000000 +0100
+++ glibc-2.3.2.27.9.7/c_stubs/gconv_stubs.c	2006-10-25 03:19:41.000000000 +0200
@@ -18,7 +18,27 @@
    Boston, MA 02111-1307, USA.  */
 
 #include <features.h>
+
+/* strange hack workaround for gcc-3.4.0.  Might be a better way. */
+#define __gconv_close_transform foo__gconv_close_transform
+#define __gconv foo__gconv
+#define __gconv_find_transform foo__gconv_find_transform
+#define __gconv_open foo__gconv_open
+#define __gconv_close foo__gconv_close
+#define __gconv_release_cache foo__gconv_release_cache
+#define __gconv_release_step foo__gconv_release_step
+
 #include <gconv_int.h>
+
+#undef __gconv_close_transform
+#undef __gconv
+#undef __gconv_find_transform
+#undef __gconv_open
+#undef __gconv_close
+#undef __gconv_release_cache
+#undef __gconv_release_step
+
+
 #include <string.h>
 #include <wchar.h>
 
diff -ru glibc-2.3.2.27.9.7.orig/elf/dl-load.c glibc-2.3.2.27.9.7/elf/dl-load.c
--- glibc-2.3.2.27.9.7.orig/elf/dl-load.c	2003-12-01 22:21:04.000000000 +0100
+++ glibc-2.3.2.27.9.7/elf/dl-load.c	2006-10-25 01:16:45.000000000 +0200
@@ -1227,7 +1227,9 @@
       }
     else
       /* Adjust the PT_PHDR value by the runtime load address.  */
-      (ElfW(Addr)) l->l_phdr += l->l_addr;
+      /* (ElfW(Addr)) l->l_phdr += l->l_addr; */
+      l->l_phdr = (ElfW(Phdr) *) ((ElfW(Addr)) l->l_phdr + l->l_addr);
+
   }
 
 #ifdef USE_TLS
@@ -1253,7 +1255,8 @@
 	}
     }
   else
-    (ElfW(Addr)) l->l_ld += l->l_addr;
+    /* (ElfW(Addr)) l->l_ld += l->l_addr; */
+    l->l_ld = (ElfW(Dyn) *) ((ElfW(Addr)) l->l_ld + l->l_addr);
 
   l->l_entry += l->l_addr;
 
diff -ru glibc-2.3.2.27.9.7.orig/elf/dl-runtime.c glibc-2.3.2.27.9.7/elf/dl-runtime.c
--- glibc-2.3.2.27.9.7.orig/elf/dl-runtime.c	2003-02-07 20:43:36.000000000 +0100
+++ glibc-2.3.2.27.9.7/elf/dl-runtime.c	2006-10-25 02:11:37.000000000 +0200
@@ -45,7 +45,7 @@
    function.  */
 
 #ifndef ELF_MACHINE_NO_PLT
-static ElfW(Addr) __attribute_used__
+ElfW(Addr) __attribute__ ((regparm (2), unused))
 fixup (
 # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
         ELF_MACHINE_RUNTIME_FIXUP_ARGS,
@@ -132,7 +132,7 @@
 
 #if !defined PROF && !defined ELF_MACHINE_NO_PLT && !__BOUNDED_POINTERS__
 
-static ElfW(Addr) __attribute_used__
+ElfW(Addr) __attribute__ ((regparm (3), unused))
 profile_fixup (
 #ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
        ELF_MACHINE_RUNTIME_FIXUP_ARGS,
diff -ru glibc-2.3.2.27.9.7.orig/elf/do-rel.h glibc-2.3.2.27.9.7/elf/do-rel.h
--- glibc-2.3.2.27.9.7.orig/elf/do-rel.h	2003-01-30 18:36:34.000000000 +0100
+++ glibc-2.3.2.27.9.7/elf/do-rel.h	2006-10-25 01:24:46.000000000 +0200
@@ -49,7 +49,7 @@
    relocations; they should be set up to call _dl_runtime_resolve, rather
    than fully resolved now.  */
 
-static inline void __attribute__ ((always_inline))
+auto inline void __attribute__ ((always_inline))
 elf_dynamic_do_rel (struct link_map *map,
 		    ElfW(Addr) reladdr, ElfW(Addr) relsize,
 		    int lazy)
diff -ru glibc-2.3.2.27.9.7.orig/elf/dynamic-link.h glibc-2.3.2.27.9.7/elf/dynamic-link.h
--- glibc-2.3.2.27.9.7.orig/elf/dynamic-link.h	2003-01-30 18:36:56.000000000 +0100
+++ glibc-2.3.2.27.9.7/elf/dynamic-link.h	2006-10-25 01:25:58.000000000 +0200
@@ -55,7 +55,12 @@
 
 /* Read the dynamic section at DYN and fill in INFO with indices DT_*.  */
 
-static inline void __attribute__ ((unused, always_inline))
+#ifndef RESOLVE_MAP
+static
+#else
+auto
+#endif
+inline void __attribute__ ((unused, always_inline))
 elf_get_dynamic_info (struct link_map *l)
 {
   ElfW(Dyn) *dyn = l->l_ld;
diff -ru glibc-2.3.2.27.9.7.orig/iconv/gconv_open.c glibc-2.3.2.27.9.7/iconv/gconv_open.c
--- glibc-2.3.2.27.9.7.orig/iconv/gconv_open.c	2001-11-29 05:51:58.000000000 +0100
+++ glibc-2.3.2.27.9.7/iconv/gconv_open.c	2006-10-24 22:52:34.000000000 +0200
@@ -182,8 +182,17 @@
 	      || __builtin_expect (__gconv_translit_find (runp), 0) == 0)
 	    lastp = runp;
 	  else
-	    /* This means we haven't found the module.  Remove it.  */
-	    (lastp == NULL ? trans : lastp->next) = runp->next;
+	    {
+	      /* This means we haven't found the module.  Remove it. */
+	      if (lastp == NULL) 
+		{
+		  trans = runp->next;
+		}
+	      else
+		{
+		  lastp->next = runp->next;
+		}
+	    }
 	}
 
       /* Allocate room for handle.  */
diff -ru glibc-2.3.2.27.9.7.orig/iconv/gconv_simple.c glibc-2.3.2.27.9.7/iconv/gconv_simple.c
--- glibc-2.3.2.27.9.7.orig/iconv/gconv_simple.c	2003-01-16 08:19:09.000000000 +0100
+++ glibc-2.3.2.27.9.7/iconv/gconv_simple.c	2006-10-24 23:10:06.000000000 +0200
@@ -1,5 +1,5 @@
 /* Simple transformations functions.
-   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1997-2003, 2004, 2005 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
@@ -72,6 +72,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 internal_ucs4_loop (struct __gconv_step *step,
 		    struct __gconv_step_data *step_data,
 		    const unsigned char **inptrp, const unsigned char *inend,
@@ -86,12 +87,13 @@
 #if __BYTE_ORDER == __LITTLE_ENDIAN
   /* Sigh, we have to do some real work.  */
   size_t cnt;
+  uint32_t *outptr32 = (uint32_t *) outptr;
 
   for (cnt = 0; cnt < n_convert; ++cnt, inptr += 4)
-    *((uint32_t *) outptr)++ = bswap_32 (*(const uint32_t *) inptr);
+    *outptr32++ = bswap_32 (*(const uint32_t *) inptr);
 
   *inptrp = inptr;
-  *outptrp = outptr;
+  *outptrp = (unsigned char *) outptr32;
 #elif __BYTE_ORDER == __BIG_ENDIAN
   /* Simply copy the data.  */
   *inptrp = inptr + n_convert * 4;
@@ -113,6 +115,7 @@
 
 #ifndef _STRING_ARCH_unaligned
 static inline int
+__attribute ((always_inline))
 internal_ucs4_loop_unaligned (struct __gconv_step *step,
 			      struct __gconv_step_data *step_data,
 			      const unsigned char **inptrp,
@@ -161,6 +164,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 internal_ucs4_loop_single (struct __gconv_step *step,
 			   struct __gconv_step_data *step_data,
 			   const unsigned char **inptrp,
@@ -189,13 +193,16 @@
   (*outptrp)[2] = state->__value.__wchb[1];
   (*outptrp)[3] = state->__value.__wchb[0];
 
-  *outptrp += 4;
 #elif __BYTE_ORDER == __BIG_ENDIAN
   /* XXX unaligned */
-  *(*((uint32_t **) outptrp)++) = state->__value.__wch;
+  (*outptrp)[0] = state->__value.__wchb[0];
+  (*outptrp)[1] = state->__value.__wchb[1];
+  (*outptrp)[2] = state->__value.__wchb[2];
+  (*outptrp)[3] = state->__value.__wchb[3];
 #else
 # error "This endianess is not supported."
 #endif
+  *outptrp += 4;
 
   /* Clear the state buffer.  */
   state->__count &= ~7;
@@ -219,6 +226,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 ucs4_internal_loop (struct __gconv_step *step,
 		    struct __gconv_step_data *step_data,
 		    const unsigned char **inptrp, const unsigned char *inend,
@@ -264,7 +272,8 @@
 	  return __GCONV_ILLEGAL_INPUT;
 	}
 
-      *((uint32_t *) outptr)++ = inval;
+      *((uint32_t *) outptr) = inval;
+      outptr += sizeof (uint32_t);
     }
 
   *inptrp = inptr;
@@ -283,6 +292,7 @@
 
 #ifndef _STRING_ARCH_unaligned
 static inline int
+__attribute ((always_inline))
 ucs4_internal_loop_unaligned (struct __gconv_step *step,
 			      struct __gconv_step_data *step_data,
 			      const unsigned char **inptrp,
@@ -352,6 +362,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 ucs4_internal_loop_single (struct __gconv_step *step,
 			   struct __gconv_step_data *step_data,
 			   const unsigned char **inptrp,
@@ -426,6 +437,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 internal_ucs4le_loop (struct __gconv_step *step,
 		      struct __gconv_step_data *step_data,
 		      const unsigned char **inptrp, const unsigned char *inend,
@@ -440,9 +452,11 @@
 #if __BYTE_ORDER == __BIG_ENDIAN
   /* Sigh, we have to do some real work.  */
   size_t cnt;
+  uint32_t *outptr32 = (uint32_t *) outptr;
 
   for (cnt = 0; cnt < n_convert; ++cnt, inptr += 4)
-    *((uint32_t *) outptr)++ = bswap_32 (*(const uint32_t *) inptr);
+    *outptr32++ = bswap_32 (*(const uint32_t *) inptr);
+  outptr = (unsigned char *) outptr32;
 
   *inptrp = inptr;
   *outptrp = outptr;
@@ -467,6 +481,7 @@
 
 #ifndef _STRING_ARCH_unaligned
 static inline int
+__attribute ((always_inline))
 internal_ucs4le_loop_unaligned (struct __gconv_step *step,
 				struct __gconv_step_data *step_data,
 				const unsigned char **inptrp,
@@ -518,6 +533,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 internal_ucs4le_loop_single (struct __gconv_step *step,
 			     struct __gconv_step_data *step_data,
 			     const unsigned char **inptrp,
@@ -546,12 +562,17 @@
   (*outptrp)[2] = state->__value.__wchb[1];
   (*outptrp)[3] = state->__value.__wchb[0];
 
-  *outptrp += 4;
 #else
   /* XXX unaligned */
-  *(*((uint32_t **) outptrp)++) = state->__value.__wch;
+  (*outptrp)[0] = state->__value.__wchb[0];
+  (*outptrp)[1] = state->__value.__wchb[1];
+  (*outptrp)[2] = state->__value.__wchb[2];
+  (*outptrp)[3] = state->__value.__wchb[3];
+
 #endif
 
+  *outptrp += 4;
+
   /* Clear the state buffer.  */
   state->__count &= ~7;
 
@@ -573,6 +594,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 ucs4le_internal_loop (struct __gconv_step *step,
 		      struct __gconv_step_data *step_data,
 		      const unsigned char **inptrp, const unsigned char *inend,
@@ -616,7 +638,8 @@
 	  return __GCONV_ILLEGAL_INPUT;
 	}
 
-      *((uint32_t *) outptr)++ = inval;
+      *((uint32_t *) outptr) = inval;
+      outptr += sizeof (uint32_t);
     }
 
   *inptrp = inptr;
@@ -638,6 +661,7 @@
 
 #ifndef _STRING_ARCH_unaligned
 static inline int
+__attribute ((always_inline))
 ucs4le_internal_loop_unaligned (struct __gconv_step *step,
 				struct __gconv_step_data *step_data,
 				const unsigned char **inptrp,
@@ -711,6 +735,7 @@
 
 
 static inline int
+__attribute ((always_inline))
 ucs4le_internal_loop_single (struct __gconv_step *step,
 			     struct __gconv_step_data *step_data,
 			     const unsigned char **inptrp,
@@ -796,7 +821,8 @@
       }									      \
     else								      \
       /* It's an one byte sequence.  */					      \
-      *((uint32_t *) outptr)++ = *inptr++;				      \
+      *((uint32_t *) outptr) = *inptr++;				      \
+      outptr += sizeof (uint32_t);					      \
   }
 #define LOOP_NEED_FLAGS
 #include <iconv/loop.c>
@@ -826,7 +852,8 @@
       }									      \
     else								      \
       /* It's an one byte sequence.  */					      \
-      *outptr++ = *((const uint32_t *) inptr)++;			      \
+      *outptr++ = *((const uint32_t *) inptr);				      \
+      inptr += sizeof (uint32_t);					      \
   }
 #define LOOP_NEED_FLAGS
 #include <iconv/loop.c>
@@ -859,7 +886,7 @@
     else if (__builtin_expect (wc <= 0x7fffffff, 1))			      \
       {									      \
 	size_t step;							      \
-	char *start;							      \
+	unsigned char *start;						      \
 									      \
 	for (step = 2; step < 6; ++step)				      \
 	  if ((wc & (~(uint32_t)0 << (5 * step + 1))) == 0)		      \
@@ -875,13 +902,12 @@
 	start = outptr;							      \
 	*outptr = (unsigned char) (~0xff >> step);			      \
 	outptr += step;							      \
-	--step;								      \
 	do								      \
 	  {								      \
-	    start[step] = 0x80 | (wc & 0x3f);				      \
+	    start[--step] = 0x80 | (wc & 0x3f);				      \
 	    wc >>= 6;							      \
 	  }								      \
-	while (--step > 0);						      \
+	while (step > 1);						      \
 	start[0] |= wc;							      \
       }									      \
     else								      \
@@ -963,18 +989,17 @@
 	  }								      \
 	else								      \
 	  {								      \
-	    int skipped;						      \
-									      \
 	    /* Search the end of this ill-formed UTF-8 character.  This	      \
 	       is the next byte with (x & 0xc0) != 0x80.  */		      \
-	    skipped = 0;						      \
+	    i = 0;							      \
 	    do								      \
-	      ++skipped;						      \
-	    while (inptr + skipped < inend				      \
-		   && (*(inptr + skipped) & 0xc0) == 0x80		      \
-		   && skipped < 5);					      \
+	      ++i;							      \
+	    while (inptr + i < inend					      \
+		   && (*(inptr + i) & 0xc0) == 0x80			      \
+		   && i < 5);						      \
 									      \
-	    STANDARD_FROM_LOOP_ERR_HANDLER (skipped);			      \
+	  errout:							      \
+	    STANDARD_FROM_LOOP_ERR_HANDLER (i);				      \
 	  }								      \
 									      \
 	if (__builtin_expect (inptr + cnt > inend, 0))			      \
@@ -991,7 +1016,7 @@
 		break;							      \
 	      }								      \
 									      \
-	    STANDARD_FROM_LOOP_ERR_HANDLER (i);				      \
+	    goto errout;						      \
 	  }								      \
 									      \
 	/* Read the possible remaining bytes.  */			      \
@@ -1013,14 +1038,15 @@
 	if (i < cnt || (cnt > 2 && (ch >> (5 * cnt - 4)) == 0))		      \
 	  {								      \
 	    /* This is an illegal encoding.  */				      \
-	    STANDARD_FROM_LOOP_ERR_HANDLER (i);				      \
+	    goto errout;						      \
 	  }								      \
 									      \
 	inptr += cnt;							      \
       }									      \
 									      \
     /* Now adjust the pointers and store the result.  */		      \
-    *((uint32_t *) outptr)++ = ch;					      \
+    *((uint32_t *) outptr) = ch;					      \
+    outptr += sizeof (uint32_t);					      \
   }
 #define LOOP_NEED_FLAGS
 
@@ -1132,7 +1158,7 @@
 #define LOOPFCT			FROM_LOOP
 #define BODY \
   {									      \
-    uint16_t u1 = *((const uint16_t *) inptr);				      \
+    uint16_t u1 = get16 (inptr);					      \
 									      \
     if (__builtin_expect (u1 >= 0xd800 && u1 < 0xe000, 0))		      \
       {									      \
@@ -1141,7 +1167,8 @@
 	STANDARD_FROM_LOOP_ERR_HANDLER (2);				      \
       }									      \
 									      \
-    *((uint32_t *) outptr)++ = u1;					      \
+    *((uint32_t *) outptr) = u1;					      \
+    outptr += sizeof (uint32_t);					      \
     inptr += 2;								      \
   }
 #define LOOP_NEED_FLAGS
@@ -1189,7 +1216,8 @@
       }									      \
     else								      \
       {									      \
-	*((uint16_t *) outptr)++ = val;					      \
+	put16 (outptr, val);						      \
+        outptr += sizeof (uint16_t);					      \
 	inptr += 4;							      \
       }									      \
   }
@@ -1214,7 +1242,7 @@
 #define LOOPFCT			FROM_LOOP
 #define BODY \
   {									      \
-    uint16_t u1 = bswap_16 (*((const uint16_t *) inptr));		      \
+    uint16_t u1 = bswap_16 (get16 (inptr));				      \
 									      \
     if (__builtin_expect (u1 >= 0xd800 && u1 < 0xe000, 0))		      \
       {									      \
@@ -1230,7 +1258,8 @@
 	continue;							      \
       }									      \
 									      \
-    *((uint32_t *) outptr)++ = u1;					      \
+    *((uint32_t *) outptr) = u1;					      \
+    outptr += sizeof (uint32_t);					      \
     inptr += 2;								      \
   }
 #define LOOP_NEED_FLAGS
@@ -1279,7 +1308,8 @@
       }									      \
     else								      \
       {									      \
-	*((uint16_t *) outptr)++ = bswap_16 (val);			      \
+	put16 (outptr, bswap_16 (val));					      \
+	outptr += sizeof (uint16_t);					      \
 	inptr += 4;							      \
       }									      \
   }
diff -ru glibc-2.3.2.27.9.7.orig/iconv/iconvconfig.c glibc-2.3.2.27.9.7/iconv/iconvconfig.c
--- glibc-2.3.2.27.9.7.orig/iconv/iconvconfig.c	2003-01-02 21:12:03.000000000 +0100
+++ glibc-2.3.2.27.9.7/iconv/iconvconfig.c	2006-10-25 02:04:36.000000000 +0200
@@ -1010,7 +1010,7 @@
   char finalname[prefix_len + sizeof (GCONV_MODULES_CACHE)];
 
   /* Function to insert the names.  */
-  static void name_insert (const void *nodep, VISIT value, int level)
+  auto void name_insert (const void *nodep, VISIT value, int level)
     {
       struct name *name;
       unsigned int idx;
diff -ru glibc-2.3.2.27.9.7.orig/locale/weight.h glibc-2.3.2.27.9.7/locale/weight.h
--- glibc-2.3.2.27.9.7.orig/locale/weight.h	2001-07-06 06:55:33.000000000 +0200
+++ glibc-2.3.2.27.9.7/locale/weight.h	2006-10-25 00:16:45.000000000 +0200
@@ -18,7 +18,8 @@
    02111-1307 USA.  */
 
 /* Find index of weight.  */
-static inline int32_t
+auto inline int32_t
+__attribute ((always_inline))
 findidx (const unsigned char **cpp)
 {
   int_fast32_t i = table[*(*cpp)++];
diff -ru glibc-2.3.2.27.9.7.orig/locale/weightwc.h glibc-2.3.2.27.9.7/locale/weightwc.h
--- glibc-2.3.2.27.9.7.orig/locale/weightwc.h	2001-08-07 06:26:15.000000000 +0200
+++ glibc-2.3.2.27.9.7/locale/weightwc.h	2006-10-25 00:24:11.000000000 +0200
@@ -18,7 +18,8 @@
    02111-1307 USA.  */
 
 /* Find index of weight.  */
-static inline int32_t
+auto inline int32_t
+__attribute ((always_inline))
 findidx (const wint_t **cpp)
 {
   int32_t i;
diff -ru glibc-2.3.2.27.9.7.orig/malloc/obstack.c glibc-2.3.2.27.9.7/malloc/obstack.c
--- glibc-2.3.2.27.9.7.orig/malloc/obstack.c	2002-11-01 21:43:32.000000000 +0100
+++ glibc-2.3.2.27.9.7/malloc/obstack.c	2006-10-25 03:04:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* obstack.c - subroutines used implicitly by object stack macros
-   Copyright (C) 1988-1994, 1996-2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.  Its master source is NOT part of
-   the C library, however.  The master source lives in /gd/gnu/lib.
+   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -15,17 +15,19 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
 
 #ifdef _LIBC
-#include <obstack.h>
+# include <obstack.h>
+# include <shlib-compat.h>
 #else
-#include "obstack.h"
+# include "obstack.h"
 #endif
 
 /* NOTE BEFORE MODIFYING THIS FILE: This version number must be
@@ -50,28 +52,38 @@
 # endif
 #endif
 
-#if defined _LIBC && defined USE_IN_LIBIO
-# include <wchar.h>
-#endif
+#include <stddef.h>
 
 #ifndef ELIDE_CODE
 
 
-# if defined __STDC__ && __STDC__
-#  define POINTER void *
-# else
-#  define POINTER char *
+# if HAVE_INTTYPES_H
+#  include <inttypes.h>
+# endif
+# if HAVE_STDINT_H || defined _LIBC
+#  include <stdint.h>
 # endif
 
 /* Determine default alignment.  */
-struct fooalign {char x; double d;};
-# define DEFAULT_ALIGNMENT  \
-  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))
+union fooround
+{
+  uintmax_t i;
+  long double d;
+  void *p;
+};
+struct fooalign
+{
+  char c;
+  union fooround u;
+};
 /* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
    But in fact it might be less smart and round addresses to as much as
    DEFAULT_ROUNDING.  So we prepare for it to do that.  */
-union fooround {long x; double d;};
-# define DEFAULT_ROUNDING (sizeof (union fooround))
+enum
+  {
+    DEFAULT_ALIGNMENT = offsetof (struct fooalign, u),
+    DEFAULT_ROUNDING = sizeof (union fooround)
+  };
 
 /* When we copy a long block of data, this is the unit to do it with.
    On some machines, copying successive ints does not work;
@@ -88,27 +100,27 @@
    abort gracefully or use longjump - but shouldn't return.  This
    variable by default points to the internal function
    `print_and_abort'.  */
-# if defined __STDC__ && __STDC__
 static void print_and_abort (void);
 void (*obstack_alloc_failed_handler) (void) = print_and_abort;
-# else
-static void print_and_abort ();
-void (*obstack_alloc_failed_handler) () = print_and_abort;
-# endif
 
 /* Exit value used when `print_and_abort' is used.  */
-# if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-# ifndef EXIT_FAILURE
-#  define EXIT_FAILURE 1
-# endif
+# include <stdlib.h>
+# ifdef _LIBC
 int obstack_exit_failure = EXIT_FAILURE;
+# else
+#  include "exitfail.h"
+#  define obstack_exit_failure exit_failure
+# endif
 
-/* The non-GNU-C macros copy the obstack into this global variable
-   to avoid multiple evaluation.  */
-
-struct obstack *_obstack;
+# ifdef _LIBC
+#  if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3_4)
+/* A looong time ago (before 1994, anyway; we're not sure) this global variable
+   was used by non-GNU-C macros to avoid multiple evaluation.  The GNU C
+   library still exports it because somebody might use it.  */
+struct obstack *_obstack_compat;
+compat_symbol (libc, _obstack_compat, _obstack, GLIBC_2_0);
+#  endif
+# endif
 
 /* Define a macro that either calls functions with the traditional malloc/free
    calling interface, or calls functions with the mmalloc/mfree interface
@@ -116,33 +128,18 @@
    For free, do not use ?:, since some compilers, like the MIPS compilers,
    do not allow (expr) ? void : void.  */
 
-# if defined __STDC__ && __STDC__
-#  define CALL_CHUNKFUN(h, size) \
+# define CALL_CHUNKFUN(h, size) \
   (((h) -> use_extra_arg) \
    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
    : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
 
-#  define CALL_FREEFUN(h, old_chunk) \
+# define CALL_FREEFUN(h, old_chunk) \
   do { \
     if ((h) -> use_extra_arg) \
       (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
     else \
       (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
   } while (0)
-# else
-#  define CALL_CHUNKFUN(h, size) \
-  (((h) -> use_extra_arg) \
-   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
-   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
-
-#  define CALL_FREEFUN(h, old_chunk) \
-  do { \
-    if ((h) -> use_extra_arg) \
-      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
-    else \
-      (*(void (*) ()) (h)->freefun) ((old_chunk)); \
-  } while (0)
-# endif
 
 
 /* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
@@ -154,22 +151,15 @@
    allocation fails.  */
 
 int
-_obstack_begin (h, size, alignment, chunkfun, freefun)
-     struct obstack *h;
-     int size;
-     int alignment;
-# if defined __STDC__ && __STDC__
-     POINTER (*chunkfun) (long);
-     void (*freefun) (void *);
-# else
-     POINTER (*chunkfun) ();
-     void (*freefun) ();
-# endif
+_obstack_begin (struct obstack *h,
+		int size, int alignment,
+		void *(*chunkfun) (long),
+		void (*freefun) (void *))
 {
   register struct _obstack_chunk *chunk; /* points to new chunk */
 
   if (alignment == 0)
-    alignment = (int) DEFAULT_ALIGNMENT;
+    alignment = DEFAULT_ALIGNMENT;
   if (size == 0)
     /* Default size is what GNU malloc can fit in a 4096-byte block.  */
     {
@@ -187,13 +177,8 @@
       size = 4096 - extra;
     }
 
-# if defined __STDC__ && __STDC__
   h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
   h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
-# else
-  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
-  h->freefun = freefun;
-# endif
   h->chunk_size = size;
   h->alignment_mask = alignment - 1;
   h->use_extra_arg = 0;
@@ -201,7 +186,8 @@
   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
   if (!chunk)
     (*obstack_alloc_failed_handler) ();
-  h->next_free = h->object_base = chunk->contents;
+  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
+					       alignment - 1);
   h->chunk_limit = chunk->limit
     = (char *) chunk + h->chunk_size;
   chunk->prev = 0;
@@ -212,23 +198,15 @@
 }
 
 int
-_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
-     struct obstack *h;
-     int size;
-     int alignment;
-# if defined __STDC__ && __STDC__
-     POINTER (*chunkfun) (POINTER, long);
-     void (*freefun) (POINTER, POINTER);
-# else
-     POINTER (*chunkfun) ();
-     void (*freefun) ();
-# endif
-     POINTER arg;
+_obstack_begin_1 (struct obstack *h, int size, int alignment,
+		  void *(*chunkfun) (void *, long),
+		  void (*freefun) (void *, void *),
+		  void *arg)
 {
   register struct _obstack_chunk *chunk; /* points to new chunk */
 
   if (alignment == 0)
-    alignment = (int) DEFAULT_ALIGNMENT;
+    alignment = DEFAULT_ALIGNMENT;
   if (size == 0)
     /* Default size is what GNU malloc can fit in a 4096-byte block.  */
     {
@@ -246,13 +224,8 @@
       size = 4096 - extra;
     }
 
-# if defined __STDC__ && __STDC__
   h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
   h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
-# else
-  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
-  h->freefun = freefun;
-# endif
   h->chunk_size = size;
   h->alignment_mask = alignment - 1;
   h->extra_arg = arg;
@@ -261,7 +234,8 @@
   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
   if (!chunk)
     (*obstack_alloc_failed_handler) ();
-  h->next_free = h->object_base = chunk->contents;
+  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
+					       alignment - 1);
   h->chunk_limit = chunk->limit
     = (char *) chunk + h->chunk_size;
   chunk->prev = 0;
@@ -278,9 +252,7 @@
    to the beginning of the new one.  */
 
 void
-_obstack_newchunk (h, length)
-     struct obstack *h;
-     int length;
+_obstack_newchunk (struct obstack *h, int length)
 {
   register struct _obstack_chunk *old_chunk = h->chunk;
   register struct _obstack_chunk *new_chunk;
@@ -305,8 +277,7 @@
 
   /* Compute an aligned object_base in the new chunk */
   object_base =
-    __INT_TO_PTR ((__PTR_TO_INT (new_chunk->contents) + h->alignment_mask)
-		  & ~ (h->alignment_mask));
+    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);
 
   /* Move the existing object to the new chunk.
      Word at a time is fast and is safe if the object
@@ -331,7 +302,10 @@
   /* If the object just copied was the only data in OLD_CHUNK,
      free that chunk and remove it from the chain.
      But not if that chunk might contain an empty object.  */
-  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
+  if (! h->maybe_empty_object
+      && (h->object_base
+	  == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,
+			  h->alignment_mask)))
     {
       new_chunk->prev = old_chunk->prev;
       CALL_FREEFUN (h, old_chunk);
@@ -342,24 +316,20 @@
   /* The new chunk certainly contains no empty object yet.  */
   h->maybe_empty_object = 0;
 }
-#ifdef _LIBC
+# ifdef _LIBC
 libc_hidden_def (_obstack_newchunk)
-#endif
+# endif
 
 /* Return nonzero if object OBJ has been allocated from obstack H.
    This is here for debugging.
    If you use it in a program, you are probably losing.  */
 
-# if defined __STDC__ && __STDC__
 /* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
    obstack.h because it is just for debugging.  */
-int _obstack_allocated_p (struct obstack *h, POINTER obj);
-# endif
+int _obstack_allocated_p (struct obstack *h, void *obj);
 
 int
-_obstack_allocated_p (h, obj)
-     struct obstack *h;
-     POINTER obj;
+_obstack_allocated_p (struct obstack *h, void *obj)
 {
   register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
   register struct _obstack_chunk *plp;	/* point to previous chunk if any */
@@ -368,7 +338,7 @@
   /* We use >= rather than > since the object cannot be exactly at
      the beginning of the chunk but might be an empty object exactly
      at the end of an adjacent chunk.  */
-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
     {
       plp = lp->prev;
       lp = plp;
@@ -381,13 +351,8 @@
 
 # undef obstack_free
 
-/* This function has two names with identical definitions.
-   This is the first one, called from non-ANSI code.  */
-
 void
-_obstack_free (h, obj)
-     struct obstack *h;
-     POINTER obj;
+obstack_free (struct obstack *h, void *obj)
 {
   register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
   register struct _obstack_chunk *plp;	/* point to previous chunk if any */
@@ -396,7 +361,7 @@
   /* We use >= because there cannot be an object at the beginning of a chunk.
      But there can be an empty object at that address
      at the end of another chunk.  */
-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
     {
       plp = lp->prev;
       CALL_FREEFUN (h, lp);
@@ -416,48 +381,14 @@
     abort ();
 }
 
-/* This function is used from ANSI code.  */
-
-#ifdef _LIBC
-strong_alias (_obstack_free, obstack_free)
-#else
-
-void
-obstack_free (h, obj)
-     struct obstack *h;
-     POINTER obj;
-{
-  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
-  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
-
-  lp = h->chunk;
-  /* We use >= because there cannot be an object at the beginning of a chunk.
-     But there can be an empty object at that address
-     at the end of another chunk.  */
-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
-    {
-      plp = lp->prev;
-      CALL_FREEFUN (h, lp);
-      lp = plp;
-      /* If we switch chunks, we can't tell whether the new current
-	 chunk contains an empty object, so assume that it may.  */
-      h->maybe_empty_object = 1;
-    }
-  if (lp)
-    {
-      h->object_base = h->next_free = (char *) (obj);
-      h->chunk_limit = lp->limit;
-      h->chunk = lp;
-    }
-  else if (obj != 0)
-    /* obj is not in any of the chunks! */
-    abort ();
-}
-#endif
+# ifdef _LIBC
+/* Older versions of libc used a function _obstack_free intended to be
+   called by non-GCC compilers.  */
+strong_alias (obstack_free, _obstack_free)
+# endif
 
 int
-_obstack_memory_used (h)
-     struct obstack *h;
+_obstack_memory_used (struct obstack *h)
 {
   register struct _obstack_chunk* lp;
   register int nbytes = 0;
@@ -470,16 +401,15 @@
 }
 
 /* Define the error handler.  */
+# ifdef _LIBC
+#  include <libintl.h>
+# else
+#  include "gettext.h"
+# endif
 # ifndef _
-#  if (HAVE_LIBINTL_H && ENABLE_NLS) || defined _LIBC
-#   include <libintl.h>
-#   ifndef _
-#    define _(Str) gettext (Str)
-#   endif
-#  else
-#   define _(Str) (Str)
-#  endif
+#  define _(msgid) gettext (msgid)
 # endif
+
 # ifdef _LIBC
 #  include <libio/iolibio.h>
 # endif
@@ -493,7 +423,7 @@
 
 static void
 __attribute__ ((noreturn))
-print_and_abort ()
+print_and_abort (void)
 {
   /* Don't change any of these strings.  Yes, it would be possible to add
      the newline to the string and use fputs or so.  But this must not
@@ -508,127 +438,5 @@
     fprintf (stderr, "%s\n", _("memory exhausted"));
   exit (obstack_exit_failure);
 }
-
-# if 0
-/* These are now turned off because the applications do not use it
-   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
-
-/* Now define the functional versions of the obstack macros.
-   Define them to simply use the corresponding macros to do the job.  */
-
-#  if defined __STDC__ && __STDC__
-/* These function definitions do not work with non-ANSI preprocessors;
-   they won't pass through the macro names in parentheses.  */
-
-/* The function names appear in parentheses in order to prevent
-   the macro-definitions of the names from being expanded there.  */
-
-POINTER (obstack_base) (obstack)
-     struct obstack *obstack;
-{
-  return obstack_base (obstack);
-}
-
-POINTER (obstack_next_free) (obstack)
-     struct obstack *obstack;
-{
-  return obstack_next_free (obstack);
-}
-
-int (obstack_object_size) (obstack)
-     struct obstack *obstack;
-{
-  return obstack_object_size (obstack);
-}
-
-int (obstack_room) (obstack)
-     struct obstack *obstack;
-{
-  return obstack_room (obstack);
-}
-
-int (obstack_make_room) (obstack, length)
-     struct obstack *obstack;
-     int length;
-{
-  return obstack_make_room (obstack, length);
-}
-
-void (obstack_grow) (obstack, data, length)
-     struct obstack *obstack;
-     const POINTER data;
-     int length;
-{
-  obstack_grow (obstack, data, length);
-}
-
-void (obstack_grow0) (obstack, data, length)
-     struct obstack *obstack;
-     const POINTER data;
-     int length;
-{
-  obstack_grow0 (obstack, data, length);
-}
-
-void (obstack_1grow) (obstack, character)
-     struct obstack *obstack;
-     int character;
-{
-  obstack_1grow (obstack, character);
-}
-
-void (obstack_blank) (obstack, length)
-     struct obstack *obstack;
-     int length;
-{
-  obstack_blank (obstack, length);
-}
-
-void (obstack_1grow_fast) (obstack, character)
-     struct obstack *obstack;
-     int character;
-{
-  obstack_1grow_fast (obstack, character);
-}
-
-void (obstack_blank_fast) (obstack, length)
-     struct obstack *obstack;
-     int length;
-{
-  obstack_blank_fast (obstack, length);
-}
-
-POINTER (obstack_finish) (obstack)
-     struct obstack *obstack;
-{
-  return obstack_finish (obstack);
-}
-
-POINTER (obstack_alloc) (obstack, length)
-     struct obstack *obstack;
-     int length;
-{
-  return obstack_alloc (obstack, length);
-}
-
-POINTER (obstack_copy) (obstack, address, length)
-     struct obstack *obstack;
-     const POINTER address;
-     int length;
-{
-  return obstack_copy (obstack, address, length);
-}
-
-POINTER (obstack_copy0) (obstack, address, length)
-     struct obstack *obstack;
-     const POINTER address;
-     int length;
-{
-  return obstack_copy0 (obstack, address, length);
-}
-
-#  endif /* __STDC__ */
-
-# endif /* 0 */
 
 #endif	/* !ELIDE_CODE */
diff -ru glibc-2.3.2.27.9.7.orig/malloc/obstack.h glibc-2.3.2.27.9.7/malloc/obstack.h
--- glibc-2.3.2.27.9.7.orig/malloc/obstack.h	2003-01-04 22:42:30.000000000 +0100
+++ glibc-2.3.2.27.9.7/malloc/obstack.h	2006-10-25 02:59:02.000000000 +0200
@@ -1,7 +1,7 @@
 /* obstack.h - object stack macros
-   Copyright (C) 1988,89,90,91,92,93,94,96,97,98,99 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.  Its master source is NOT part of
-   the C library, however.  The master source lives in /gd/gnu/lib.
+   Copyright (C) 1988-1994,1996-1999,2003,2004,2005
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -15,8 +15,8 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
 
 /* Summary:
 
@@ -110,49 +110,36 @@
 extern "C" {
 #endif
 
-/* We use subtraction of (char *) 0 instead of casting to int
-   because on word-addressable machines a simple cast to int
-   may ignore the byte-within-word field of the pointer.  */
-
-#ifndef __PTR_TO_INT
-# define __PTR_TO_INT(P) ((P) - (char *) 0)
-#endif
-
-#ifndef __INT_TO_PTR
-#if defined __STDC__ && __STDC__
-# define __INT_TO_PTR(P) ((void *) ((P) + (char *) 0))
-#else
-# define __INT_TO_PTR(P) ((P) + (char *) 0)
-#endif
-#endif
-
-/* We need the type of the resulting object.  If __PTRDIFF_TYPE__ is
+/* We need the type of a pointer subtraction.  If __PTRDIFF_TYPE__ is
    defined, as with GNU C, use that; that way we don't pollute the
-   namespace with <stddef.h>'s symbols.  Otherwise, if <stddef.h> is
-   available, include it and use ptrdiff_t.  In traditional C, long is
-   the best that we can do.  */
+   namespace with <stddef.h>'s symbols.  Otherwise, include <stddef.h>
+   and use ptrdiff_t.  */
 
 #ifdef __PTRDIFF_TYPE__
 # define PTR_INT_TYPE __PTRDIFF_TYPE__
 #else
-# ifdef HAVE_STDDEF_H
-#  include <stddef.h>
-#  define PTR_INT_TYPE ptrdiff_t
-# else
-#  define PTR_INT_TYPE long
-# endif
+# include <stddef.h>
+# define PTR_INT_TYPE ptrdiff_t
 #endif
 
-#if defined _LIBC || defined HAVE_STRING_H
-# include <string.h>
-# define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))
-#else
-# ifdef memcpy
-#  define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))
-# else
-#  define _obstack_memcpy(To, From, N) bcopy ((From), (To), (N))
-# endif
-#endif
+/* If B is the base of an object addressed by P, return the result of
+   aligning P to the next multiple of A + 1.  B and P must be of type
+   char *.  A + 1 must be a power of 2.  */
+
+#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))
+
+/* Similiar to _BPTR_ALIGN (B, P, A), except optimize the common case
+   where pointers can be converted to integers, aligned as integers,
+   and converted back again.  If PTR_INT_TYPE is narrower than a
+   pointer (e.g., the AS/400), play it safe and compute the alignment
+   relative to B.  Otherwise, use the faster strategy of computing the
+   alignment relative to 0.  */
+
+#define __PTR_ALIGN(B, P, A)						    \
+  __BPTR_ALIGN (sizeof (PTR_INT_TYPE) < sizeof (void *) ? (B) : (char *) 0, \
+		P, A)
+
+#include <string.h>
 
 struct _obstack_chunk		/* Lives at front of each chunk. */
 {
@@ -168,20 +155,18 @@
   char	*object_base;		/* address of object we are building */
   char	*next_free;		/* where to add next char to current object */
   char	*chunk_limit;		/* address of char after current chunk */
-  PTR_INT_TYPE temp;		/* Temporary for some macros.  */
+  union
+  {
+    PTR_INT_TYPE tempint;
+    void *tempptr;
+  } temp;			/* Temporary for some macros.  */
   int   alignment_mask;		/* Mask of alignment for each object. */
-#if defined __STDC__ && __STDC__
   /* These prototypes vary based on `use_extra_arg', and we use
      casts to the prototypeless function type in all assignments,
      but having prototypes here quiets -Wstrict-prototypes.  */
   struct _obstack_chunk *(*chunkfun) (void *, long);
   void (*freefun) (void *, struct _obstack_chunk *);
   void *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
-#else
-  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */
-  void (*freefun) ();		/* User's function to free a chunk.  */
-  char *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
-#endif
   unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
   unsigned maybe_empty_object:1;/* There is a possibility that the current
 				   chunk contains a zero-length object.  This
@@ -194,77 +179,22 @@
 
 /* Declare the external functions we use; they are in obstack.c.  */
 
-#if defined __STDC__ && __STDC__
 extern void _obstack_newchunk (struct obstack *, int);
-extern void _obstack_free (struct obstack *, void *);
 extern int _obstack_begin (struct obstack *, int, int,
 			    void *(*) (long), void (*) (void *));
 extern int _obstack_begin_1 (struct obstack *, int, int,
 			     void *(*) (void *, long),
 			     void (*) (void *, void *), void *);
 extern int _obstack_memory_used (struct obstack *);
-#else
-extern void _obstack_newchunk ();
-extern void _obstack_free ();
-extern int _obstack_begin ();
-extern int _obstack_begin_1 ();
-extern int _obstack_memory_used ();
-#endif
-
-#if defined __STDC__ && __STDC__
-
-/* Do the function-declarations after the structs
-   but before defining the macros.  */
-
-void obstack_init (struct obstack *obstack);
-
-void * obstack_alloc (struct obstack *obstack, int size);
-
-void * obstack_copy (struct obstack *obstack, const void *address, int size);
-void * obstack_copy0 (struct obstack *obstack, const void *address, int size);
 
 void obstack_free (struct obstack *obstack, void *block);
 
-void obstack_blank (struct obstack *obstack, int size);
-
-void obstack_grow (struct obstack *obstack, const void *data, int size);
-void obstack_grow0 (struct obstack *obstack, const void *data, int size);
-
-void obstack_1grow (struct obstack *obstack, int data_char);
-void obstack_ptr_grow (struct obstack *obstack, const void *data);
-void obstack_int_grow (struct obstack *obstack, int data);
-
-void * obstack_finish (struct obstack *obstack);
-
-int obstack_object_size (struct obstack *obstack);
-
-int obstack_room (struct obstack *obstack);
-void obstack_make_room (struct obstack *obstack, int size);
-void obstack_1grow_fast (struct obstack *obstack, int data_char);
-void obstack_ptr_grow_fast (struct obstack *obstack, const void *data);
-void obstack_int_grow_fast (struct obstack *obstack, int data);
-void obstack_blank_fast (struct obstack *obstack, int size);
-
-void * obstack_base (struct obstack *obstack);
-void * obstack_next_free (struct obstack *obstack);
-int obstack_alignment_mask (struct obstack *obstack);
-int obstack_chunk_size (struct obstack *obstack);
-int obstack_memory_used (struct obstack *obstack);
-
-#endif /* __STDC__ */
-
-/* Non-ANSI C cannot really support alternative functions for these macros,
-   so we do not declare them.  */
-
+
 /* Error handler called when `obstack_chunk_alloc' failed to allocate
    more memory.  This can be set to a user defined function which
    should either abort gracefully or use longjump - but shouldn't
    return.  The default action is to print a message and abort.  */
-#if defined __STDC__ && __STDC__
 extern void (*obstack_alloc_failed_handler) (void);
-#else
-extern void (*obstack_alloc_failed_handler) ();
-#endif
 
 /* Exit value used when `print_and_abort' is used.  */
 extern int obstack_exit_failure;
@@ -273,7 +203,7 @@
    Note that this might not be the final address of the object
    because a new chunk might be needed to hold the final size.  */
 
-#define obstack_base(h) ((h)->object_base)
+#define obstack_base(h) ((void *) (h)->object_base)
 
 /* Size for allocating ordinary chunks.  */
 
@@ -287,67 +217,34 @@
 
 #define obstack_alignment_mask(h) ((h)->alignment_mask)
 
-/* To prevent prototype warnings provide complete argument list in
-   standard C version.  */
-#if defined __STDC__ && __STDC__
-
-# define obstack_init(h)					\
+/* To prevent prototype warnings provide complete argument list.  */
+#define obstack_init(h)						\
   _obstack_begin ((h), 0, 0,					\
-		  (void *(*) (long)) obstack_chunk_alloc, 	\
+		  (void *(*) (long)) obstack_chunk_alloc,	\
 		  (void (*) (void *)) obstack_chunk_free)
 
-# define obstack_begin(h, size)					\
+#define obstack_begin(h, size)					\
   _obstack_begin ((h), (size), 0,				\
-		  (void *(*) (long)) obstack_chunk_alloc, 	\
+		  (void *(*) (long)) obstack_chunk_alloc,	\
 		  (void (*) (void *)) obstack_chunk_free)
 
-# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
+#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun)  \
   _obstack_begin ((h), (size), (alignment),				   \
-		  (void *(*) (long)) (chunkfun), 			   \
+		  (void *(*) (long)) (chunkfun),			   \
 		  (void (*) (void *)) (freefun))
 
-# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
+#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
   _obstack_begin_1 ((h), (size), (alignment),				\
 		    (void *(*) (void *, long)) (chunkfun),		\
 		    (void (*) (void *, void *)) (freefun), (arg))
 
-# define obstack_chunkfun(h, newchunkfun) \
+#define obstack_chunkfun(h, newchunkfun) \
   ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))
 
-# define obstack_freefun(h, newfreefun) \
+#define obstack_freefun(h, newfreefun) \
   ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))
 
-#else
-
-# define obstack_init(h)						\
-  _obstack_begin ((h), 0, 0,						\
-		  (void *(*) ()) obstack_chunk_alloc, 			\
-		  (void (*) ()) obstack_chunk_free)
-
-# define obstack_begin(h, size)						\
-  _obstack_begin ((h), (size), 0,					\
-		  (void *(*) ()) obstack_chunk_alloc,			\
-		  (void (*) ()) obstack_chunk_free)
-
-# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
-  _obstack_begin ((h), (size), (alignment),				   \
-		  (void *(*) ()) (chunkfun), 				   \
-		  (void (*) ()) (freefun))
-
-# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
-  _obstack_begin_1 ((h), (size), (alignment),				\
-		    (void *(*) ()) (chunkfun), 				\
-		    (void (*) ()) (freefun), (arg))
-
-# define obstack_chunkfun(h, newchunkfun) \
-  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))
-
-# define obstack_freefun(h, newfreefun) \
-  ((h) -> freefun = (void (*)()) (newfreefun))
-
-#endif
-
-#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)
+#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))
 
 #define obstack_blank_fast(h,n) ((h)->next_free += (n))
 
@@ -368,12 +265,12 @@
 
 # define obstack_object_size(OBSTACK)					\
   __extension__								\
-  ({ struct obstack *__o = (OBSTACK);					\
+  ({ struct obstack const *__o = (OBSTACK);				\
      (unsigned) (__o->next_free - __o->object_base); })
 
 # define obstack_room(OBSTACK)						\
   __extension__								\
-  ({ struct obstack *__o = (OBSTACK);					\
+  ({ struct obstack const *__o = (OBSTACK);				\
      (unsigned) (__o->chunk_limit - __o->next_free); })
 
 # define obstack_make_room(OBSTACK,length)				\
@@ -386,8 +283,11 @@
 
 # define obstack_empty_p(OBSTACK)					\
   __extension__								\
-  ({ struct obstack *__o = (OBSTACK);					\
-     (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })
+  ({ struct obstack const *__o = (OBSTACK);				\
+     (__o->chunk->prev == 0						\
+      && __o->next_free == __PTR_ALIGN ((char *) __o->chunk,		\
+					__o->chunk->contents,		\
+					__o->alignment_mask)); })
 
 # define obstack_grow(OBSTACK,where,length)				\
 __extension__								\
@@ -395,7 +295,7 @@
    int __len = (length);						\
    if (__o->next_free + __len > __o->chunk_limit)			\
      _obstack_newchunk (__o, __len);					\
-   _obstack_memcpy (__o->next_free, (where), __len);			\
+   memcpy (__o->next_free, where, __len);				\
    __o->next_free += __len;						\
    (void) 0; })
 
@@ -405,7 +305,7 @@
    int __len = (length);						\
    if (__o->next_free + __len + 1 > __o->chunk_limit)			\
      _obstack_newchunk (__o, __len + 1);				\
-   _obstack_memcpy (__o->next_free, (where), __len);			\
+   memcpy (__o->next_free, where, __len);				\
    __o->next_free += __len;						\
    *(__o->next_free)++ = 0;						\
    (void) 0; })
@@ -415,7 +315,7 @@
 ({ struct obstack *__o = (OBSTACK);					\
    if (__o->next_free + 1 > __o->chunk_limit)				\
      _obstack_newchunk (__o, 1);					\
-   *(__o->next_free)++ = (datum);					\
+   obstack_1grow_fast (__o, datum);					\
    (void) 0; })
 
 /* These assume that the obstack alignment is good enough for pointers
@@ -427,22 +327,28 @@
 ({ struct obstack *__o = (OBSTACK);					\
    if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
      _obstack_newchunk (__o, sizeof (void *));				\
-   *((void **)__o->next_free)++ = (datum);				\
-   (void) 0; })
+   obstack_ptr_grow_fast (__o, datum); })				\
 
 # define obstack_int_grow(OBSTACK,datum)				\
 __extension__								\
 ({ struct obstack *__o = (OBSTACK);					\
    if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
      _obstack_newchunk (__o, sizeof (int));				\
-   *((int *)__o->next_free)++ = (datum);				\
-   (void) 0; })
+   obstack_int_grow_fast (__o, datum); })
 
-# define obstack_ptr_grow_fast(h,aptr)					\
-  (*((void **) (h)->next_free)++ = (aptr))
+# define obstack_ptr_grow_fast(OBSTACK,aptr)				\
+__extension__								\
+({ struct obstack *__o1 = (OBSTACK);					\
+   *(const void **) __o1->next_free = (aptr);				\
+   __o1->next_free += sizeof (const void *);				\
+   (void) 0; })
 
-# define obstack_int_grow_fast(h,aint)					\
-  (*((int *) (h)->next_free)++ = (aint))
+# define obstack_int_grow_fast(OBSTACK,aint)				\
+__extension__								\
+({ struct obstack *__o1 = (OBSTACK);					\
+   *(int *) __o1->next_free = (aint);					\
+   __o1->next_free += sizeof (int);					\
+   (void) 0; })
 
 # define obstack_blank(OBSTACK,length)					\
 __extension__								\
@@ -450,7 +356,7 @@
    int __len = (length);						\
    if (__o->chunk_limit - __o->next_free < __len)			\
      _obstack_newchunk (__o, __len);					\
-   __o->next_free += __len;						\
+   obstack_blank_fast (__o, __len);					\
    (void) 0; })
 
 # define obstack_alloc(OBSTACK,length)					\
@@ -473,21 +379,20 @@
 
 /* The local variable is named __o1 to avoid a name conflict
    when obstack_blank is called.  */
-# define obstack_finish(OBSTACK)  					\
+# define obstack_finish(OBSTACK)					\
 __extension__								\
 ({ struct obstack *__o1 = (OBSTACK);					\
-   void *value;								\
-   value = (void *) __o1->object_base;					\
-   if (__o1->next_free == value)					\
+   void *__value = (void *) __o1->object_base;				\
+   if (__o1->next_free == __value)					\
      __o1->maybe_empty_object = 1;					\
    __o1->next_free							\
-     = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\
-		     & ~ (__o1->alignment_mask));			\
+     = __PTR_ALIGN (__o1->object_base, __o1->next_free,			\
+		    __o1->alignment_mask);				\
    if (__o1->next_free - (char *)__o1->chunk				\
        > __o1->chunk_limit - (char *)__o1->chunk)			\
      __o1->next_free = __o1->chunk_limit;				\
    __o1->object_base = __o1->next_free;					\
-   value; })
+   __value; })
 
 # define obstack_free(OBSTACK, OBJ)					\
 __extension__								\
@@ -506,7 +411,10 @@
  (unsigned) ((h)->chunk_limit - (h)->next_free)
 
 # define obstack_empty_p(h) \
- ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)
+ ((h)->chunk->prev == 0							\
+  && (h)->next_free == __PTR_ALIGN ((char *) (h)->chunk,		\
+				    (h)->chunk->contents,		\
+				    (h)->alignment_mask))
 
 /* Note that the call to _obstack_newchunk is enclosed in (..., 0)
    so that we can avoid having void expressions
@@ -515,51 +423,51 @@
    but some compilers won't accept it.  */
 
 # define obstack_make_room(h,length)					\
-( (h)->temp = (length),							\
-  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))
+( (h)->temp.tempint = (length),						\
+  (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0))
 
 # define obstack_grow(h,where,length)					\
-( (h)->temp = (length),							\
-  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
-  _obstack_memcpy ((h)->next_free, (where), (h)->temp),			\
-  (h)->next_free += (h)->temp)
+( (h)->temp.tempint = (length),						\
+  (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
+  memcpy ((h)->next_free, where, (h)->temp.tempint),			\
+  (h)->next_free += (h)->temp.tempint)
 
 # define obstack_grow0(h,where,length)					\
-( (h)->temp = (length),							\
-  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)			\
-   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),			\
-  _obstack_memcpy ((h)->next_free, (where), (h)->temp),			\
-  (h)->next_free += (h)->temp,						\
+( (h)->temp.tempint = (length),						\
+  (((h)->next_free + (h)->temp.tempint + 1 > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint + 1), 0) : 0),		\
+  memcpy ((h)->next_free, where, (h)->temp.tempint),			\
+  (h)->next_free += (h)->temp.tempint,					\
   *((h)->next_free)++ = 0)
 
 # define obstack_1grow(h,datum)						\
 ( (((h)->next_free + 1 > (h)->chunk_limit)				\
    ? (_obstack_newchunk ((h), 1), 0) : 0),				\
-  (*((h)->next_free)++ = (datum)))
+  obstack_1grow_fast (h, datum))
 
 # define obstack_ptr_grow(h,datum)					\
 ( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
    ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
-  (*((const char **) (((h)->next_free+=sizeof(char *))-sizeof(char *))) = (datum)))
+  obstack_ptr_grow_fast (h, datum))
 
 # define obstack_int_grow(h,datum)					\
 ( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
    ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
-  (*((int *) (((h)->next_free+=sizeof(int))-sizeof(int))) = (datum)))
+  obstack_int_grow_fast (h, datum))
 
 # define obstack_ptr_grow_fast(h,aptr)					\
-  (*((const char **) (h)->next_free)++ = (aptr))
+  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))
 
 # define obstack_int_grow_fast(h,aint)					\
-  (*((int *) (h)->next_free)++ = (aint))
+  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aint))
 
 # define obstack_blank(h,length)					\
-( (h)->temp = (length),							\
-  (((h)->chunk_limit - (h)->next_free < (h)->temp)			\
-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
-  ((h)->next_free += (h)->temp))
+( (h)->temp.tempint = (length),						\
+  (((h)->chunk_limit - (h)->next_free < (h)->temp.tempint)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
+  obstack_blank_fast (h, (h)->temp.tempint))
 
 # define obstack_alloc(h,length)					\
  (obstack_blank ((h), (length)), obstack_finish ((h)))
@@ -570,35 +478,27 @@
 # define obstack_copy0(h,where,length)					\
  (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
 
-# define obstack_finish(h)  						\
+# define obstack_finish(h)						\
 ( ((h)->next_free == (h)->object_base					\
    ? (((h)->maybe_empty_object = 1), 0)					\
    : 0),								\
-  (h)->temp = __PTR_TO_INT ((h)->object_base),				\
+  (h)->temp.tempptr = (h)->object_base,					\
   (h)->next_free							\
-    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)	\
-		    & ~ ((h)->alignment_mask)),				\
+    = __PTR_ALIGN ((h)->object_base, (h)->next_free,			\
+		   (h)->alignment_mask),				\
   (((h)->next_free - (char *) (h)->chunk				\
     > (h)->chunk_limit - (char *) (h)->chunk)				\
    ? ((h)->next_free = (h)->chunk_limit) : 0),				\
   (h)->object_base = (h)->next_free,					\
-  __INT_TO_PTR ((h)->temp))
+  (h)->temp.tempptr)
 
-# if defined __STDC__ && __STDC__
-#  define obstack_free(h,obj)						\
-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,			\
-  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
-   ? (int) ((h)->next_free = (h)->object_base				\
-	    = (h)->temp + (char *) (h)->chunk)				\
-   : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))
-# else
-#  define obstack_free(h,obj)						\
-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,			\
-  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
+# define obstack_free(h,obj)						\
+( (h)->temp.tempint = (char *) (obj) - (char *) (h)->chunk,		\
+  ((((h)->temp.tempint > 0						\
+    && (h)->temp.tempint < (h)->chunk_limit - (char *) (h)->chunk))	\
    ? (int) ((h)->next_free = (h)->object_base				\
-	    = (h)->temp + (char *) (h)->chunk)				\
-   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))
-# endif
+	    = (h)->temp.tempint + (char *) (h)->chunk)			\
+   : (((obstack_free) ((h), (h)->temp.tempint + (char *) (h)->chunk), 0), 0)))
 
 #endif /* not __GNUC__ or not __STDC__ */
 
diff -ru glibc-2.3.2.27.9.7.orig/posix/regcomp.c glibc-2.3.2.27.9.7/posix/regcomp.c
--- glibc-2.3.2.27.9.7.orig/posix/regcomp.c	2003-02-21 02:21:03.000000000 +0100
+++ glibc-2.3.2.27.9.7/posix/regcomp.c	2006-10-25 00:28:35.000000000 +0200
@@ -2511,7 +2511,8 @@
      Seek the collating symbol entry correspondings to NAME.
      Return the index of the symbol in the SYMB_TABLE.  */
 
-  static inline int32_t
+  auto inline int32_t
+    __attribute ((always_inline))
   seek_collating_symbol_entry (name, name_len)
 	 const unsigned char *name;
 	 size_t name_len;
@@ -2543,7 +2544,8 @@
      Look up the collation sequence value of BR_ELEM.
      Return the value if succeeded, UINT_MAX otherwise.  */
 
-  static inline unsigned int
+  auto inline unsigned int
+    __attribute ((always_inline))
   lookup_collation_sequence_value (br_elem)
 	 bracket_elem_t *br_elem;
     {
@@ -2610,7 +2612,8 @@
      mbcset->range_ends, is a pointer argument sinse we may
      update it.  */
 
-  static inline reg_errcode_t
+  auto inline reg_errcode_t
+  __attribute ((always_inline))
 # ifdef RE_ENABLE_I18N
   build_range_exp (sbcset, mbcset, range_alloc, start_elem, end_elem)
 	 re_charset_t *mbcset;
@@ -2696,7 +2699,8 @@
      COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a
      pointer argument sinse we may update it.  */
 
-  static inline reg_errcode_t
+  auto inline reg_errcode_t
+  __attribute ((always_inline))
 # ifdef RE_ENABLE_I18N
   build_collating_symbol (sbcset, mbcset, coll_sym_alloc, name)
 	 re_charset_t *mbcset;
diff -ru glibc-2.3.2.27.9.7.orig/stdlib/msort.c glibc-2.3.2.27.9.7/stdlib/msort.c
--- glibc-2.3.2.27.9.7.orig/stdlib/msort.c	2002-09-24 06:20:57.000000000 +0200
+++ glibc-2.3.2.27.9.7/stdlib/msort.c	2006-10-24 23:14:30.000000000 +0200
@@ -1,6 +1,6 @@
 /* An alternative to qsort, with an identical interface.
    This file is part of the GNU C Library.
-   Copyright (C) 1992,95-97,99,2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 1992,95-97,99,2000,01,02,04 Free Software Foundation, Inc.
    Written by Mike Haertel, September 1988.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -56,12 +56,16 @@
 	if ((*cmp) (b1, b2) <= 0)
 	  {
 	    --n1;
-	    *((op_t *) tmp)++ = *((op_t *) b1)++;
+	    *((op_t *) tmp) = *((op_t *) b1);
+	    tmp += sizeof (op_t);
+	    b1 += sizeof (op_t);
 	  }
 	else
 	  {
 	    --n2;
-	    *((op_t *) tmp)++ = *((op_t *) b2)++;
+	    *((op_t *) tmp) = *((op_t *) b2);
+	    tmp += sizeof (op_t);
+	    b2 += sizeof (op_t);
 	  }
       }
   else
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/clnt_perr.c glibc-2.3.2.27.9.7/sunrpc/clnt_perr.c
--- glibc-2.3.2.27.9.7.orig/sunrpc/clnt_perr.c	2002-11-01 21:43:54.000000000 +0100
+++ glibc-2.3.2.27.9.7/sunrpc/clnt_perr.c	2006-10-25 00:34:25.000000000 +0200
@@ -55,7 +55,7 @@
  * buf variable in a few functions.  Overriding a global variable
  * with a local variable of the same name is a bad idea, anyway.
  */
-#define buf ((char *)RPC_THREAD_VARIABLE(clnt_perr_buf_s))
+#define buf RPC_THREAD_VARIABLE(clnt_perr_buf_s)
 #else
 static char *buf;
 #endif
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/clnt_raw.c glibc-2.3.2.27.9.7/sunrpc/clnt_raw.c
--- glibc-2.3.2.27.9.7.orig/sunrpc/clnt_raw.c	2002-05-15 02:21:00.000000000 +0200
+++ glibc-2.3.2.27.9.7/sunrpc/clnt_raw.c	2006-10-25 00:36:36.000000000 +0200
@@ -61,7 +61,7 @@
     u_int mcnt;
   };
 #ifdef _RPC_THREAD_SAFE_
-#define clntraw_private ((struct clntraw_private_s *)RPC_THREAD_VARIABLE(clntraw_private_s))
+#define clntraw_private RPC_THREAD_VARIABLE(clntraw_private_s)
 #else
 static struct clntraw_private_s *clntraw_private;
 #endif
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/clnt_simp.c glibc-2.3.2.27.9.7/sunrpc/clnt_simp.c
--- glibc-2.3.2.27.9.7.orig/sunrpc/clnt_simp.c	2002-05-15 02:21:00.000000000 +0200
+++ glibc-2.3.2.27.9.7/sunrpc/clnt_simp.c	2006-10-25 00:37:57.000000000 +0200
@@ -55,7 +55,7 @@
     char *oldhost;
   };
 #ifdef _RPC_THREAD_SAFE_
-#define callrpc_private ((struct callrpc_private_s *)RPC_THREAD_VARIABLE(callrpc_private_s))
+#define callrpc_private RPC_THREAD_VARIABLE(callrpc_private_s)
 #else
 static struct callrpc_private_s *callrpc_private;
 #endif
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/key_call.c glibc-2.3.2.27.9.7/sunrpc/key_call.c
--- glibc-2.3.2.27.9.7.orig/sunrpc/key_call.c	2002-08-06 08:08:50.000000000 +0200
+++ glibc-2.3.2.27.9.7/sunrpc/key_call.c	2006-10-25 01:06:18.000000000 +0200
@@ -370,7 +370,7 @@
   uid_t   uid;            /* user-id at last authorization */
 };
 #ifdef _RPC_THREAD_SAFE_
-#define key_call_private_main ((struct  key_call_private *)RPC_THREAD_VARIABLE(key_call_private_s))
+#define key_call_private_main RPC_THREAD_VARIABLE(key_call_private_s)
 #else
 static struct key_call_private *key_call_private_main;
 #endif
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/rpc/xdr.h glibc-2.3.2.27.9.7/sunrpc/rpc/xdr.h
--- glibc-2.3.2.27.9.7.orig/sunrpc/rpc/xdr.h	2002-12-16 03:05:49.000000000 +0100
+++ glibc-2.3.2.27.9.7/sunrpc/rpc/xdr.h	2006-10-25 00:42:41.000000000 +0200
@@ -262,12 +262,10 @@
  * and shouldn't be used any longer. Code which use this defines or longs
  * in the RPC code will not work on 64bit Solaris platforms !
  */
-#define IXDR_GET_LONG(buf) \
-	((long)ntohl((u_long)*__extension__((u_int32_t*)(buf))++))
-#define IXDR_PUT_LONG(buf, v) \
-	(*__extension__((u_int32_t*)(buf))++ = (long)htonl((u_long)(v)))
-#define IXDR_GET_U_LONG(buf)	      ((u_long)IXDR_GET_LONG(buf))
-#define IXDR_PUT_U_LONG(buf, v)	      IXDR_PUT_LONG(buf, (long)(v))
+#define IXDR_GET_LONG(buf) ((long)IXDR_GET_U_INT32(buf))
+#define IXDR_PUT_LONG(buf, v) ((long)IXDR_PUT_INT32(buf, (long)(v)))
+#define IXDR_GET_U_LONG(buf)          ((u_long)IXDR_GET_LONG(buf))
+#define IXDR_PUT_U_LONG(buf, v)       IXDR_PUT_LONG(buf, (long)(v))
 
 
 #define IXDR_GET_BOOL(buf)            ((bool_t)IXDR_GET_LONG(buf))
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/svcauth_des.c glibc-2.3.2.27.9.7/sunrpc/svcauth_des.c
--- glibc-2.3.2.27.9.7.orig/sunrpc/svcauth_des.c	2001-08-20 08:37:09.000000000 +0200
+++ glibc-2.3.2.27.9.7/sunrpc/svcauth_des.c	2006-10-25 01:11:54.000000000 +0200
@@ -72,8 +72,8 @@
     char *localcred;		/* generic local credential */
   };
 #ifdef _RPC_THREAD_SAFE_
-#define authdes_cache ((struct cache_entry *)RPC_THREAD_VARIABLE(authdes_cache_s))
-#define authdes_lru ((int *)RPC_THREAD_VARIABLE(authdes_lru_s))
+#define authdes_cache RPC_THREAD_VARIABLE(authdes_cache_s)
+#define authdes_lru RPC_THREAD_VARIABLE(authdes_lru_s)
 #else
 static struct cache_entry *authdes_cache;
 static int *authdes_lru;
@@ -211,9 +211,9 @@
 
       /* XXX This could be wrong, but else we have a
 	 security problem */
-      if (authdes_cache[sid].rname == NULL)
+      if (((struct cache_entry *)authdes_cache)[sid].rname == NULL)
 	return AUTH_BADCRED;
-      sessionkey = &authdes_cache[sid].key;
+      sessionkey = &((struct cache_entry *)authdes_cache)[sid].key;
     }
 
 
@@ -281,7 +281,7 @@
       }
     else
       {				/* ADN_NICKNAME */
-	window = authdes_cache[sid].window;
+	window = ((struct cache_entry *)authdes_cache)[sid].window;
 	nick = 1;
       }
 
@@ -291,7 +291,7 @@
 	/* cached out (bad key), or garbled verifier */
 	return nick ? AUTH_REJECTEDVERF : AUTH_BADVERF;
       }
-    if (nick && BEFORE (&timestamp, &authdes_cache[sid].laststamp))
+    if (nick && BEFORE (&timestamp, &((struct cache_entry *)authdes_cache)[sid].laststamp))
       {
 	debug ("timestamp before last seen");
 	return AUTH_REJECTEDVERF;	/* replay */
@@ -347,7 +347,7 @@
    * We succeeded, commit the data to the cache now and
    * finish cooking the credential.
    */
-  entry = &authdes_cache[sid];
+  entry = &((struct cache_entry *)authdes_cache)[sid];
   entry->laststamp = timestamp;
   cache_ref (sid);
   if (cred->adc_namekind == ADN_FULLNAME)
@@ -406,7 +406,7 @@
    * Initialize the lru list
    */
   for (i = 0; i < AUTHDES_CACHESZ; ++i)
-    authdes_lru[i] = i;
+    ((int *)authdes_lru)[i] = i;
 }
 
 
@@ -416,7 +416,7 @@
 static short
 cache_victim (void)
 {
-  return authdes_lru[AUTHDES_CACHESZ - 1];
+  return ((int *)authdes_lru)[AUTHDES_CACHESZ - 1];
 }
 
 /*
@@ -430,12 +430,12 @@
   register int curr;
   register int prev;
 
-  prev = authdes_lru[0];
-  authdes_lru[0] = sid;
+  prev = ((int *)authdes_lru)[0];
+  ((int *)authdes_lru)[0] = sid;
   for (i = 1; prev != sid; ++i)
     {
-      curr = authdes_lru[i];
-      authdes_lru[i] = prev;
+      curr = ((int *)authdes_lru)[i];
+      ((int *)authdes_lru)[i] = prev;
       prev = curr;
     }
 }
@@ -514,11 +514,11 @@
       debug ("invalid nickname");
       return 0;
     }
-  cred = (struct bsdcred *) authdes_cache[sid].localcred;
+  cred = (struct bsdcred *) ((struct cache_entry *)authdes_cache)[sid].localcred;
   if (cred == NULL)
     {
       cred = (struct bsdcred *) mem_alloc (sizeof (struct bsdcred));
-      authdes_cache[sid].localcred = (char *) cred;
+      ((struct cache_entry *)authdes_cache)[sid].localcred = (char *) cred;
       cred->grouplen = INVALID;
     }
   if (cred->grouplen == INVALID)
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/svc.c glibc-2.3.2.27.9.7/sunrpc/svc.c
--- glibc-2.3.2.27.9.7.orig/sunrpc/svc.c	2002-08-06 07:10:30.000000000 +0200
+++ glibc-2.3.2.27.9.7/sunrpc/svc.c	2006-10-25 01:03:37.000000000 +0200
@@ -44,7 +44,7 @@
 #include <sys/poll.h>
 
 #ifdef _RPC_THREAD_SAFE_
-#define xports ((SVCXPRT **)RPC_THREAD_VARIABLE(svc_xports_s))
+#define xports RPC_THREAD_VARIABLE(svc_xports_s)
 #else
 static SVCXPRT **xports;
 #endif
@@ -63,7 +63,7 @@
   void (*sc_dispatch) (struct svc_req *, SVCXPRT *);
 };
 #ifdef _RPC_THREAD_SAFE_
-#define svc_head ((struct svc_callout *)RPC_THREAD_VARIABLE(svc_head_s))
+#define svc_head RPC_THREAD_VARIABLE(svc_head_s)
 #else
 static struct svc_callout *svc_head;
 #endif
@@ -88,7 +88,7 @@
     {
       struct pollfd *new_svc_pollfd;
 
-      xports[sock] = xprt;
+      ((SVCXPRT **)xports)[sock] = xprt;
       if (sock < FD_SETSIZE)
 	FD_SET (sock, &svc_fdset);
 
@@ -124,9 +124,9 @@
   register int sock = xprt->xp_sock;
   register int i;
 
-  if ((sock < _rpc_dtablesize ()) && (xports[sock] == xprt))
+  if ((sock < _rpc_dtablesize ()) && (((SVCXPRT **)xports)[sock] == xprt))
     {
-      xports[sock] = (SVCXPRT *) 0;
+      ((SVCXPRT **)xports)[sock] = (SVCXPRT *) 0;
 
       if (sock < FD_SETSIZE)
 	FD_CLR (sock, &svc_fdset);
@@ -391,7 +391,7 @@
 	  ++fds_found;
 
 	  if (p->revents & POLLNVAL)
-	    xprt_unregister (xports[p->fd]);
+	    xprt_unregister (((SVCXPRT **)xports)[p->fd]);
 	  else
 	    INTUSE(svc_getreq_common) (p->fd);
 	}
@@ -410,7 +410,7 @@
   msg.rm_call.cb_cred.oa_base = cred_area;
   msg.rm_call.cb_verf.oa_base = &(cred_area[MAX_AUTH_BYTES]);
 
-  xprt = xports[fd];
+  xprt = ((SVCXPRT **)xports)[fd];
   /* Do we control fd? */
   if (xprt == NULL)
      return;
diff -ru glibc-2.3.2.27.9.7.orig/sunrpc/svc_simple.c glibc-2.3.2.27.9.7/sunrpc/svc_simple.c
--- glibc-2.3.2.27.9.7.orig/sunrpc/svc_simple.c	2002-08-06 07:10:30.000000000 +0200
+++ glibc-2.3.2.27.9.7/sunrpc/svc_simple.c	2006-10-25 01:04:18.000000000 +0200
@@ -61,7 +61,7 @@
     struct proglst_ *p_nxt;
   };
 #ifdef _RPC_THREAD_SAFE_
-#define proglst ((struct proglst_ *)RPC_THREAD_VARIABLE(svcsimple_proglst_s))
+#define proglst RPC_THREAD_VARIABLE(svcsimple_proglst_s)
 #else
 static struct proglst_ *proglst;
 #endif
@@ -69,7 +69,7 @@
 
 static void universal (struct svc_req *rqstp, SVCXPRT *transp_s);
 #ifdef _RPC_THREAD_SAFE_
-#define transp ((SVCXPRT *)RPC_THREAD_VARIABLE(svcsimple_transp_s))
+#define transp RPC_THREAD_VARIABLE(svcsimple_transp_s)
 #else
 static SVCXPRT *transp;
 #endif
diff -ru glibc-2.3.2.27.9.7.orig/sysdeps/generic/strtoll.c glibc-2.3.2.27.9.7/sysdeps/generic/strtoll.c
--- glibc-2.3.2.27.9.7.orig/sysdeps/generic/strtoll.c	2001-07-06 06:55:50.000000000 +0200
+++ glibc-2.3.2.27.9.7/sysdeps/generic/strtoll.c	2006-10-25 00:08:04.000000000 +0200
@@ -30,5 +30,7 @@
 #  endif
 
 # endif
+#ifndef USE_IN_EXTENDED_LOCALE_MODEL
 weak_alias (strtoll, strtoq)
 #endif
+#endif
diff -ru glibc-2.3.2.27.9.7.orig/sysdeps/generic/strtoull.c glibc-2.3.2.27.9.7/sysdeps/generic/strtoull.c
--- glibc-2.3.2.27.9.7.orig/sysdeps/generic/strtoull.c	2001-07-06 06:55:50.000000000 +0200
+++ glibc-2.3.2.27.9.7/sysdeps/generic/strtoull.c	2006-10-25 00:09:19.000000000 +0200
@@ -30,5 +30,7 @@
 #  endif
 
 # endif
+#ifndef USE_IN_EXTENDED_LOCALE_MODEL
 weak_alias (strtoull, strtouq)
 #endif
+#endif
diff -ru glibc-2.3.2.27.9.7.orig/sysdeps/generic/wcstoll.c glibc-2.3.2.27.9.7/sysdeps/generic/wcstoll.c
--- glibc-2.3.2.27.9.7.orig/sysdeps/generic/wcstoll.c	2001-07-06 06:55:50.000000000 +0200
+++ glibc-2.3.2.27.9.7/sysdeps/generic/wcstoll.c	2006-10-25 00:22:39.000000000 +0200
@@ -21,5 +21,6 @@
 #define	QUAD	1
 
 #include "wcstol.c"
-
+#ifndef USE_IN_EXTENDED_LOCALE_MODEL
 weak_alias (wcstoll, wcstoq)
+#endif
diff -ru glibc-2.3.2.27.9.7.orig/sysdeps/generic/wcstoull.c glibc-2.3.2.27.9.7/sysdeps/generic/wcstoull.c
--- glibc-2.3.2.27.9.7.orig/sysdeps/generic/wcstoull.c	2001-07-06 06:55:50.000000000 +0200
+++ glibc-2.3.2.27.9.7/sysdeps/generic/wcstoull.c	2006-10-25 00:22:55.000000000 +0200
@@ -21,5 +21,6 @@
 #define	QUAD	1
 
 #include "wcstoul.c"
-
+#ifndef USE_IN_EXTENDED_LOCALE_MODEL
 weak_alias (wcstoull, wcstouq)
+#endif
diff -ru glibc-2.3.2.27.9.7.orig/sysdeps/i386/dl-machine.h glibc-2.3.2.27.9.7/sysdeps/i386/dl-machine.h
--- glibc-2.3.2.27.9.7.orig/sysdeps/i386/dl-machine.h	2003-01-12 09:50:09.000000000 +0100
+++ glibc-2.3.2.27.9.7/sysdeps/i386/dl-machine.h	2006-10-25 02:11:53.000000000 +0200
@@ -154,9 +154,9 @@
    destroys the passed register information.  */
 /* GKM FIXME: Fix trampoline to pass bounds so we can do
    without the `__unbounded' qualifier.  */
-static ElfW(Addr) fixup (struct link_map *__unbounded l, ElfW(Word) reloc_offset)
+ElfW(Addr) fixup (struct link_map *__unbounded l, ElfW(Word) reloc_offset)
      __attribute__ ((regparm (2), unused));
-static ElfW(Addr) profile_fixup (struct link_map *l, ElfW(Word) reloc_offset,
+ElfW(Addr) profile_fixup (struct link_map *l, ElfW(Word) reloc_offset,
 				 ElfW(Addr) retaddr)
      __attribute__ ((regparm (3), unused));
 # endif
@@ -360,7 +360,8 @@
 /* Perform the relocation specified by RELOC and SYM (which is fully resolved).
    MAP is the object containing the reloc.  */
 
-static inline void
+auto inline void
+__attribute ((always_inline))
 elf_machine_rel (struct link_map *map, const Elf32_Rel *reloc,
 		 const Elf32_Sym *sym, const struct r_found_version *version,
 		 Elf32_Addr *const reloc_addr)
@@ -503,7 +504,8 @@
 }
 
 #ifndef RTLD_BOOTSTRAP
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
 		  const Elf32_Sym *sym, const struct r_found_version *version,
 		  Elf32_Addr *const reloc_addr)
@@ -604,7 +606,8 @@
 }
 #endif	/* !RTLD_BOOTSTRAP */
 
-static inline void
+auto inline void
+__attribute ((always_inline))
 elf_machine_rel_relative (Elf32_Addr l_addr, const Elf32_Rel *reloc,
 			  Elf32_Addr *const reloc_addr)
 {
@@ -613,7 +616,8 @@
 }
 
 #ifndef RTLD_BOOTSTRAP
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
 			   Elf32_Addr *const reloc_addr)
 {
@@ -621,7 +625,8 @@
 }
 #endif	/* !RTLD_BOOTSTRAP */
 
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_lazy_rel (struct link_map *map,
 		      Elf32_Addr l_addr, const Elf32_Rel *reloc)
 {
@@ -642,7 +647,8 @@
 
 #ifndef RTLD_BOOTSTRAP
 
-static inline void
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_lazy_rela (struct link_map *map,
 		       Elf32_Addr l_addr, const Elf32_Rela *reloc)
 {
